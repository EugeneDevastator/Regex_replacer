<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Regex Pattern Helper</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            margin: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
        }
        
        .editor-container {
            position: relative;
            width: 100%;
            height: 500px;
        }
        
        #editor {
            width: 100%;
            height: 100%;
            background: #2d2d30;
            color: #d4d4d4;
            border: 1px solid #3e3e42;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: none;
            outline: none;
        }
        
        .input-overlay {
            position: absolute;
            background: #252526;
            border: 2px solid #007acc;
            border-radius: 4px;
            padding: 8px;
            display: none;
            z-index: 1001;
            min-width: 300px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .input-overlay input {
            width: 100%;
            background: #3c3c3c;
            border: 1px solid #555;
            color: #d4d4d4;
            padding: 4px 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            outline: none;
        }
        
        .input-overlay .hint {
            color: #6a9955;
            font-size: 11px;
            margin-bottom: 4px;
        }
        
        .autocomplete-popup {
            position: absolute;
            background: #252526;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            min-width: 300px;
        }
        
        .autocomplete-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #3e3e42;
            font-size: 12px;
        }
        
        .autocomplete-item:hover,
        .autocomplete-item.selected {
            background: #094771;
        }
        
        .autocomplete-item:last-child {
            border-bottom: none;
        }
        
        .pattern-desc {
            color: #6a9955;
            font-style: italic;
        }
        
        .status {
            margin-top: 10px;
            padding: 8px;
            background: #2d2d30;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            font-size: 12px;
            color: #6a9955;
        }
    </style>
</head>
<body>
    <h1>Regex Pattern Helper</h1>
    <p>Type to get pattern suggestions. Select a pattern, then type its content and press Enter.</p>
    <div class="editor-container">
        <textarea id="editor" placeholder="Start typing... Try 'any', 'digit', 'word', etc."></textarea>
        <div id="autocomplete" class="autocomplete-popup"></div>
        <div id="inputOverlay" class="input-overlay">
            <div class="hint" id="inputHint">Enter content for pattern:</div>
            <input type="text" id="patternInput" placeholder="Type content here...">
        </div>
    </div>
    <div id="status" class="status">Ready - Start typing to see suggestions</div>

    <script>
        const editor = document.getElementById('editor');
        const autocompletePopup = document.getElementById('autocomplete');
        const inputOverlay = document.getElementById('inputOverlay');
        const patternInput = document.getElementById('patternInput');
        const inputHint = document.getElementById('inputHint');
        const status = document.getElementById('status');
        
        const regexPatterns = {
            // Basic patterns
            'any': { pattern: '.', desc: 'Matches any single character except newline', needsContent: false },
            'digit': { pattern: '\\d', desc: 'Matches any digit (0-9)', needsContent: false },
            'digits': { pattern: '\\d+', desc: 'Matches one or more digits', needsContent: false },
            'word': { pattern: '\\w+', desc: 'Matches word characters', needsContent: false },
            'space': { pattern: '\\s', desc: 'Matches whitespace', needsContent: false },
            'spaces': { pattern: '\\s+', desc: 'Matches one or more whitespace', needsContent: false },
            
            // Anchors
            'start': { pattern: '^', desc: 'Start of string/line', needsContent: false },
            'end': { pattern: '$', desc: 'End of string/line', needsContent: false },
            'boundary': { pattern: '\\b', desc: 'Word boundary', needsContent: false },
            
            // Quantifiers with content
            'optional': { pattern: '({content})?', desc: 'Zero or one occurrence', needsContent: true },
            'multiple': { pattern: '({content})+', desc: 'One or more occurrences', needsContent: true },
            'any amount': { pattern: '({content})*', desc: 'Zero or more occurrences', needsContent: true },
            'exactly': { pattern: '({content}){n}', desc: 'Exactly n occurrences (replace n)', needsContent: true },
            'between': { pattern: '({content}){n,m}', desc: 'Between n and m occurrences', needsContent: true },
            
            // Character classes with content
            'any of': { pattern: '[{content}]', desc: 'Any one of the specified characters', needsContent: true },
            'not': { pattern: '[^{content}]', desc: 'Any character except specified', needsContent: true },
            'range': { pattern: '[{content}]', desc: 'Character range (e.g., a-z, 0-9)', needsContent: true },
            
            // Groups with content
            'group': { pattern: '({content})', desc: 'Capturing group', needsContent: true },
            'non capturing': { pattern: '(?:{content})', desc: 'Non-capturing group', needsContent: true },
            'or': { pattern: '{content}|{content}', desc: 'Alternation - separate with |', needsContent: true },
            
            // Lookarounds with content
            'followed by': { pattern: '(?={content})', desc: 'Positive lookahead', needsContent: true },
            'not followed by': { pattern: '(?!{content})', desc: 'Negative lookahead', needsContent: true },
            'preceded by': { pattern: '(?<={content})', desc: 'Positive lookbehind', needsContent: true },
            'not preceded by': { pattern: '(?<!{content})', desc: 'Negative lookbehind', needsContent: true },
            
            // Literal escaping
            'literal': { pattern: '\\{content}', desc: 'Escape special characters', needsContent: true },
            
            // Common patterns
            'email': { pattern: '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}', desc: 'Basic email pattern', needsContent: false },
            'phone': { pattern: '\\(?\\d{3}\\)?[-.]?\\d{3}[-.]?\\d{4}', desc: 'US phone number', needsContent: false },
            'url': { pattern: 'https?://[^\\s]+', desc: 'Basic URL pattern', needsContent: false },
            'ip': { pattern: '\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b', desc: 'IPv4 address', needsContent: false },
            'hex': { pattern: '#[a-fA-F0-9]{6}', desc: 'Hex color code', needsContent: false },
            'date': { pattern: '\\d{1,2}/\\d{1,2}/\\d{4}', desc: 'Date MM/DD/YYYY', needsContent: false }
        };
        
        let currentSuggestions = [];
        let selectedIndex = -1;
        let currentPattern = null;
        let insertPosition = 0;
        let isInputMode = false;
        
        function updateStatus(message) {
            status.textContent = message;
        }
        
        function getTypedWord() {
            const cursorPos = editor.selectionStart;
            const text = editor.value;
            
            let start = cursorPos;
            while (start > 0 && /[a-zA-Z\s]/.test(text[start - 1])) {
                start--;
            }
            
            const word = text.substring(start, cursorPos).trim().toLowerCase();
            return { word, start, end: cursorPos };
        }
        
        function showAutocomplete(suggestions) {
            if (suggestions.length === 0) {
                hideAutocomplete();
                return;
            }
            
            autocompletePopup.innerHTML = '';
            currentSuggestions = suggestions;
            selectedIndex = 0;
            
            suggestions.forEach((suggestion, index) => {
                const item = document.createElement('div');
                item.className = 'autocomplete-item';
                if (index === 0) item.classList.add('selected');
                
                const contentIndicator = suggestion.needsContent ? ' ??' : '';
                item.innerHTML = `
                    <strong>${suggestion.key}${contentIndicator}</strong> ? <code>${suggestion.pattern.replace('{content}', '...')}</code><br>
                    <span class="pattern-desc">${suggestion.desc}</span>
                `;
                
                item.addEventListener('click', () => selectPattern(suggestion));
                autocompletePopup.appendChild(item);
            });
            
            const pos = getCursorPosition();
            autocompletePopup.style.left = pos.x + 'px';
            autocompletePopup.style.top = pos.y + 'px';
            autocompletePopup.style.display = 'block';
            
            updateStatus(`Found ${suggestions.length} patterns. Use ?? to navigate, Enter to select.`);
        }
        
        function hideAutocomplete() {
            autocompletePopup.style.display = 'none';
            currentSuggestions = [];
            selectedIndex = -1;
        }
        
        function showInputOverlay(pattern) {
            const pos = getCursorPosition();
            inputHint.textContent = `Enter content for "${pattern.key}":`;
            patternInput.value = '';
            patternInput.placeholder = pattern.desc;
            
            inputOverlay.style.left = pos.x + 'px';
            inputOverlay.style.top = (pos.y + 30) + 'px';
            inputOverlay.style.display = 'block';
            
            setTimeout(() => patternInput.focus(), 50);
            isInputMode = true;
            
            updateStatus(`Type content for "${pattern.key}" and press Enter. ESC to cancel.`);
        }
        
        function hideInputOverlay() {
            inputOverlay.style.display = 'none';
            isInputMode = false;
            currentPattern = null;
            editor.focus();
        }
        
        function selectPattern(pattern) {
            hideAutocomplete();
            currentPattern = pattern;
            
            const wordInfo = getTypedWord();
            insertPosition = wordInfo.start;
            
            if (pattern.needsContent) {
                showInputOverlay(pattern);
            } else {
                insertPattern(pattern.pattern);
                updateStatus(`Inserted "${pattern.key}" pattern.`);
            }
        }
        
        function insertPattern(patternText) {
            const text = editor.value;
            const wordInfo = getTypedWord();
            
            const before = text.substring(0, wordInfo.start);
            const after = text.substring(wordInfo.end);
            const newText = before + patternText + after;
            
            editor.value = newText;
            
            const newCursorPos = wordInfo.start + patternText.length;
            editor.setSelectionRange(newCursorPos, newCursorPos);
            
            editor.focus();
        }
        
        function applyPatternWithContent(content) {
            if (!currentPattern) return;
            
            let finalPattern = currentPattern.pattern.replace(/{content}/g, content);
            insertPattern(finalPattern);
            
            hideInputOverlay();
            updateStatus(`Inserted "${currentPattern.key}" with content: ${content}`);
        }
        
        function updateSelection(direction) {
            if (currentSuggestions.length === 0) return;
            
            const items = autocompletePopup.querySelectorAll('.autocomplete-item');
            items[selectedIndex].classList.remove('selected');
            
            selectedIndex += direction;
            if (selectedIndex < 0) selectedIndex = currentSuggestions.length - 1;
            if (selectedIndex >= currentSuggestions.length) selectedIndex = 0;
            
            items[selectedIndex].classList.add('selected');
            items[selectedIndex].scrollIntoView({ block: 'nearest' });
        }
        
        function getCursorPosition() {
            const cursorPos = editor.selectionStart;
            const textBeforeCursor = editor.value.substring(0, cursorPos);
            const lines = textBeforeCursor.split('\n');
            const currentLine = lines.length - 1;
            const currentColumn = lines[currentLine].length;
            
            const lineHeight = 20;
            const charWidth = 8.4;
            
            return {
                x: Math.min(currentColumn * charWidth + 10, window.innerWidth - 350),
                y: currentLine * lineHeight + 30
            };
        }
        
        // Editor event listeners
        editor.addEventListener('input', (e) => {
            if (isInputMode) return;
            
            const wordInfo = getTypedWord();
            const currentWord = wordInfo.word;
            
            if (currentWord.length > 0) {
                const matches = Object.entries(regexPatterns)
                    .filter(([key]) => key.toLowerCase().includes(currentWord))
                    .map(([key, value]) => ({ 
                        key, 
                        pattern: value.pattern, 
                        desc: value.desc,
                        needsContent: value.needsContent
                    }))
                    .sort((a, b) => {
                        const aStarts = a.key.toLowerCase().startsWith(currentWord);
                        const bStarts = b.key.toLowerCase().startsWith(currentWord);
                        if (aStarts && !bStarts) return -1;
                        if (!aStarts && bStarts) return 1;
                        return a.key.length - b.key.length;
                    });
                
                if (matches.length > 0) {
                    showAutocomplete(matches);
                } else {
                    hideAutocomplete();
                    updateStatus('No matching patterns found.');
                }
            } else {
                hideAutocomplete();
                updateStatus('Ready - Start typing to see suggestions');
            }
        });
        
        editor.addEventListener('keydown', (e) => {
            if (isInputMode) return;
            
            if (autocompletePopup.style.display === 'block') {
                switch (e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        updateSelection(1);
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        updateSelection(-1);
                        break;
                    case 'Enter':
                    case 'Tab':
                        e.preventDefault();
                        if (selectedIndex >= 0 && currentSuggestions[selectedIndex]) {
                            selectPattern(currentSuggestions[selectedIndex]);
                        }
                        break;
                    case 'Escape':
                        hideAutocomplete();
                        updateStatus('Cancelled selection.');
                        break;
                }
            }
        });
        
        // Pattern input event listeners
        patternInput.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'Enter':
                    e.preventDefault();
                    const content = patternInput.value.trim();
                    if (content) {
                        applyPatternWithContent(content);
                    } else {
                        updateStatus('Please enter content for the pattern.');
                    }
                    break;
                case 'Escape':
                    hideInputOverlay();
                    updateStatus('Cancelled pattern input.');
                    break;
            }
        });
        
        // Click outside handlers
        document.addEventListener('click', (e) => {
            if (!editor.contains(e.target) && 
                !autocompletePopup.contains(e.target) && 
                !inputOverlay.contains(e.target)) {
                hideAutocomplete();
                hideInputOverlay();
            }
        });
        
        // Focus handlers
        editor.addEventListener('blur', () => {
            if (!isInputMode) {
                setTimeout(() => {
                    if (!patternInput.matches(':focus')) {
                        hideAutocomplete();
                    }
                }, 150);
            }
        });
        
        // Initialize
        updateStatus('Ready - Start typing to see suggestions');
    </script>
</body>
</html>
